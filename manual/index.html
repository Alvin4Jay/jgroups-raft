<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<meta name="author" content="Bela Ban &lt;belaban@yahoo.com&gt;">
<title>Distributed consensus with jgroups-raft</title>
<style>

</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Distributed consensus with jgroups-raft</h1>
<div class="details">
<span id="author" class="author">Bela Ban &lt;belaban@yahoo.com&gt;</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_overview">1. Overview</a>
<ul class="sectlevel2">
<li><a href="#_architecture">1.1. Architecture</a></li>
</ul>
</li>
<li><a href="#_using_jgroups_raft">2. Using jgroups-raft</a>
<ul class="sectlevel2">
<li><a href="#_cluster_members_and_identity">2.1. Cluster members and identity</a></li>
<li><a href="#_rafthandle">2.2. RaftHandle</a>
<ul class="sectlevel3">
<li><a href="#_creation">2.2.1. Creation</a></li>
<li><a href="#_making_changes">2.2.2. Making changes</a></li>
<li><a href="#ImplementingStateMachine">2.2.3. Implementing a StateMachine</a></li>
<li><a href="#Snapshots">2.2.4. Snapshotting and state transfer</a></li>
<li><a href="#_miscellaneous_methods">2.2.5. Miscellaneous methods</a></li>
</ul>
</li>
<li><a href="#_configuration">2.3. Configuration</a></li>
<li><a href="#DynamicMembership">2.4. Adding and removing members dynamically</a></li>
</ul>
</li>
<li><a href="#BuildingBlocks">3. Building blocks</a>
<ul class="sectlevel2">
<li><a href="#ReplicatedStateMachine">3.1. ReplicatedStateMachine</a></li>
<li><a href="#CounterService">3.2. CounterService</a>
<ul class="sectlevel3">
<li><a href="#_reads_and_consensus">3.2.1. Reads and consensus</a></li>
</ul>
</li>
<li><a href="#_cluster_singleton_service">3.3. Cluster singleton service</a></li>
</ul>
</li>
<li><a href="#protlist">4. List of protocols</a>
<ul class="sectlevel2">
<li><a href="#NO_DUPES">4.1. NO_DUPES</a></li>
<li><a href="#ELECTION">4.2. ELECTION</a></li>
<li><a href="#RAFT">4.3. RAFT</a></li>
<li><a href="#REDIRECT">4.4. REDIRECT</a></li>
<li><a href="#CLIENT">4.5. CLIENT</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Copyright Red Hat 2014 - 2020</p>
</div>
<div class="paragraph">
<p>This document is licensed under the
<a href="http://creativecommons.org/licenses/by-sa/3.0/us/legalcode">"Creative Commons Attribution-ShareAlike (CC-BY-SA) 3.0"</a>
license.</p>
</div>
<div class="paragraph">
<p>This is the jgroups-raft manual. It provides information about</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Design and architecture</p>
</li>
<li>
<p>Configuration and use</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>of jgroups-raft.</p>
</div>
<div class="paragraph">
<p>Bela Ban, Kreuzlingen Switzerland 2017</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview">1. Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="http://www.github.com/belaban/jgroups-raft">jgroups-raft</a> project is an implementation of
<a href="https://raftconsensus.github.io/">Raft</a> in <a href="http://www.jgroups.org">JGroups</a>.</p>
</div>
<div class="paragraph">
<p>It provides a consensus based system where leader election and changes are committed by <em>consensus</em> (majority agreement).
A fixed number of nodes form a cluster and each node is a state machine. A leader is elected by consensus and all
changes happen through the leader which replicates them to all nodes, which add them to their persistent log.</p>
</div>
<div class="paragraph">
<p>Because Raft guarantees that there&#8217;s only ever one leader at any time, and changes are identified uniquely, all state
machines receive the same ordered stream of updates and thus have the exact same state.</p>
</div>
<div class="paragraph">
<p>Raft favors <em>consistency</em> over <em>availability</em>; in terms of the <a href="http://en.wikipedia.org/wiki/CAP_theorem">Cap theorem</a>,
jgroups-raft is a CP system. This means jgroups-raft is highly consistent, and the data replicated to nodes will never
diverge, even in the face of network partitions (split brains).</p>
</div>
<div class="paragraph">
<p>In case of a network partition, in a cluster of <code>N</code> nodes, at least <code>N/2+1</code> nodes have to be running for the
system to be available.</p>
</div>
<div class="paragraph">
<p>If for example, in a 5 node cluster, 2 nodes go down, then the system can still commit changes
and elect leaders as 3 is still the majority. However, if another node goes down, the system becomes unavailable and client
requests will be rejected. (Depending on configuration, there may still be some limited form of read-only availability.)</p>
</div>
<div class="paragraph">
<p>By implementing jgroups-raft in JGroups, the following benefits can be had:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Transports already available: UDP, TCP</p>
<div class="ulist">
<ul>
<li>
<p>Contains thread pools, priority delivery (OOB), batching etc</p>
</li>
</ul>
</div>
</li>
<li>
<p>Variety of discovery protocols</p>
</li>
<li>
<p>Encryption, authentication, compression</p>
</li>
<li>
<p>Fragmentation, reliability over UDP</p>
</li>
<li>
<p>Multicasting for larger clusters</p>
</li>
<li>
<p>Failure detection</p>
</li>
<li>
<p>Sync/async cluster RPCs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The code required to be written for a full Raft implementation is smaller than if it had been implemented outside of JGroups.</p>
</div>
<div class="paragraph">
<p>The feature set of jgroups-raft includes</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Leader election and append entries functionality by consensus</p>
</li>
<li>
<p>Persistent log (using LevelDB)</p>
</li>
<li>
<p>Dynamic addition and removal of cluster nodes</p>
</li>
<li>
<p>Cluster wide atomic counters</p>
</li>
<li>
<p>Replicated hash maps (replicated state machines)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_architecture">1.1. Architecture</h3>
<div class="paragraph">
<p>The architecture of jgroups-raft is shown below.</p>
</div>
<div id="ArchitectureFig" class="imageblock">
<div class="content">
<img src="images/Architecture.png" alt="Architecture of jgroups-raft,align=left,valign=top,width=" width="60%"">
</div>
<div class="title">Figure 1. The architecture of jgroups-raft</div>
</div>
<div class="paragraph">
<p>The components that make up jgroups-raft are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A JGroups protocol stack with jgroups-raft specific protocols added:</p>
<div class="ulist">
<ul>
<li>
<p><code>NO_DUPES</code>: makes sure that a jgroups-raft node does not appear in a view more than once</p>
</li>
<li>
<p><code>ELECTION</code>: handles leader election</p>
</li>
<li>
<p><code>RAFT</code>: implements the Raft algorithm, ie. appending entries to the persistent log, committing them, syncing new members etc</p>
</li>
<li>
<p><code>REDIRECT</code> (not shown): redirects requests to the leader</p>
</li>
<li>
<p><code>CLIENT</code>: accepts client requests over a socket, executes them and sends the results back to the clients</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>Channel</code>: this is a regular JGroups <code>JChannel</code> or <code>ForkChannel</code></p>
</li>
<li>
<p><code>RaftHandle</code>: the main class for users of jgroups-raft to interact with</p>
</li>
<li>
<p><code>StateMachine</code>: an implementation of <code>StateMachine</code>. This is typically a replicated state machine. jgroups-raft
ships with a number of building blocks implementing <code>StateMachine</code> such as <code>CounterService</code> or <code>ReplicatedStateMachine</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The figure above shows one node in a cluster, but the other nodes have the same setup except that every node is required
to have a different <code>raft_id</code> (defined in <code>RAFT</code>). This is a string which defines one cluster member; all members
need to have different raft_ids (more on this later).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_jgroups_raft">2. Using jgroups-raft</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_cluster_members_and_identity">2.1. Cluster members and identity</h3>
<div class="paragraph">
<p>Each cluster member has an address (a UUID) assigned by JGroups and a <code>raft_id</code> which needs to be assigned by the user.
The latter is a string (e.g. "A") which needs to be unique in the entire cluster. In other words, the <code>raft_id</code> is the
<em>identity</em> of a member for the sake of jgroups-raft.</p>
</div>
<div class="paragraph">
<p>A Raft cluster has a fixed size, so that a majority can be computed for leader election and appending of entries. The
members allowed into the cluster is defined in <code>RAFT.members</code>, e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;raft.RAFT members="A,B,C" raft_id="${raft_id:undefined}"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This defines a cluster of 3 members: "A", "B" and "C" (whose majority is 2).</p>
</div>
<div class="paragraph">
<p>These are the <code>raft_id</code> attributes of the 3 members, so attribute <code>raft_id</code> in the example above needs to be one of them.
If we don&#8217;t start this member with the system property <code>-Draft_id=X</code> (where X needs to be "A", "B", or "C"),
then the member will start up as "undefined" is not a member of <code>{"A", "B", "C"}</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
Note that while <code>RAFT</code> ensures that non-members cannot join a cluster, the <code>NO_DUPES</code> protocol makes sure that
no duplicate member can join. Example: if we have <code>RAFT.members="A,B,C"</code> and actual members "A" and "B" joined, then
a join attempt by a member with duplicate name "B" will be rejected and that member won&#8217;t be able to join.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Attribute <code>raft_id</code> is also used to define the location of the persistent log; unless <code>log_name</code> is defined in
<code>RAFT</code>, the location is computed as <code>&lt;temp_dir&gt;/&lt;raft_id&gt;.log</code>, e.g. <code>/tmp/A.log</code>.</p>
</div>
<div class="paragraph">
<p>Note that members can be added and removed dynamically (without taking the entire cluster down, changing the configuration
and restarting it), see <a href="#DynamicMembership">Adding and removing members dynamically</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_rafthandle">2.2. RaftHandle</h3>
<div class="paragraph">
<p>As shown in <a href="#ArchitectureFig">The architecture of jgroups-raft</a>, <code>RaftHandle</code> is the main class users will be dealing with. It provides methods to change
state (append entries) in the replicated state machines, and a state machine can be registered with it. The state machine
will be initialized at startup and updated by jgroups-raft whenever there is a change.</p>
</div>
<div class="paragraph">
<p>A successful change is committed to the persistent logs of all cluster members and applied to their state machines, so
all state machines have exactly the same state.</p>
</div>
<div class="sect3">
<h4 id="_creation">2.2.1. Creation</h4>
<div class="paragraph">
<p>An instance of RaftHandle is associated with exactly <em>one</em> JGroups channel, and can be created as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">JChannel ch=new JChannel("/home/bela/raft.xml"); <img src="./images/icons/callouts/1.png" alt="1">
RaftHandle handle=new RaftHandle(ch, this);      <img src="./images/icons/callouts/2.png" alt="2">
ch.connect("raft-cluster");                      <img src="./images/icons/callouts/3.png" alt="3"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>A new JGroups channel is created (see the JGroups manual for details on the JGroups API)</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>A RaftHandle instance is created over the channel (which must be non-null). The second argument is an implementation
of <code>StateMachine</code>. If null, no changes will be applied. The state machine can be set with <code>stateMachine(StateMachine sm)</code>.</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>The channel is connected which causes the member to join the cluster</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_making_changes">2.2.2. Making changes</h4>
<div class="paragraph">
<p>The <code>setX()</code> methods can be used to make changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">byte[] set(byte[] buf, int offset, int length) throws Exception; <img src="./images/icons/callouts/1.png" alt="1">
byte[] set(byte[] buf, int offset, int length, long timeout, TimeUnit unit) throws Exception; <img src="./images/icons/callouts/2.png" alt="2">
CompletableFuture&lt;byte[]&gt; setAsync(byte[] buf, int offset, int length); <img src="./images/icons/callouts/3.png" alt="3"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>Synchronous change; the caller will be blocked until the change has been forwarded to the leader, which sends it to
all cluster members which apply it to their persistent logs and ack the change back to the leader. Once the leader
gets a majority of acks, it commits the change to its own log, applies it to its state machine and returns the
response to the caller. The state machines thus only contain <em>committed changes</em>.</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>Same as above, except that this call is bounded with a timeout. If it elapses before a majority of acks have been
received, a <code>TimeoutException</code> will be thrown.</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>Asynchronous change; this method returns immediately with a <code>CompletableFuture</code> which can be used to retrieve the
result later, or to provide some code that&#8217;s executed as soon as the result is available (e.g. <code>whenComplete()</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The contents of the request and response buffers is application specific.</p>
</div>
<div class="paragraph">
<p>For example, if we implemented a replicated hash map, then a request could be a <code>put(key,value)</code>. The <code>put()</code>
would have to be serialized into the buffer, as well as the key and the value.</p>
</div>
<div class="paragraph">
<p>When committing the change, every state machine needs to de-serialize the buffer into a <code>put(key,value)</code> and apply it to
its state (see <a href="#ImplementingStateMachine">Implementing a StateMachine</a>). If there is a return value to the <code>put()</code> call, e.g. the previous value
associated with <code>key</code>, then it will be serialized into a buffer and returned as result of one of the <code>setX()</code> calls.</p>
</div>
</div>
<div class="sect3">
<h4 id="ImplementingStateMachine">2.2.3. Implementing a StateMachine</h4>
<div class="paragraph">
<p><code>StateMachine</code> is an interface and is defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface StateMachine {
    byte[] apply(byte[] data, int offset, int length) throws Exception;  <img src="./images/icons/callouts/1.png" alt="1">
    void   readContentFrom(DataInput in) throws Exception;               <img src="./images/icons/callouts/2.png" alt="2">
    void   writeContentTo(DataOutput out) throws Exception;              <img src="./images/icons/callouts/3.png" alt="3">
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>This method is called whenever a log entry is <em>committed</em>. The buffer&#8217;s contents are application specific (e.g this
could be a serialized <code>put(key,value)</code> as discussed above. If there is a return value of applying the change to the
state machine, it needs to be serialized so that it can be returned to the caller (e.g. a client).</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>This method is called when <code>RAFT</code> needs to initialize a state machine from a <em>snapshot</em> (a dump of a state
machine&#8217;s contents to an external stream (e.g. a file)). The <code>writeContentTo()</code> method below wrote the contents
to a file before, in an application specific format, and this method now needs to read the contents back into the
state machine.</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>This method is the opposite of <code>readContentFrom()</code> and writes the contents of this state machine to a stream
(e.g. a file).</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="Snapshots">2.2.4. Snapshotting and state transfer</h4>
<div class="paragraph">
<p>All cluster members maintain a persistent log and append all changes as log entries to the end of the log. To prevent
logs from growing indefinitely, a <em>snapshot</em> of the state machine can be made and the log truncated. This is done
(programatically) with method <code>snapshot()</code>, or declaratively (see below).</p>
</div>
<div class="paragraph">
<p>This method calls <code>StateMachine.writeContentTo()</code> to dump the state of the state machine into a snapshot file and then
truncates the log. New members who don&#8217;t have a log yet are initialized by sending them the snapshot first. After that,
they will catch up via the regular Raft mechanism.</p>
</div>
<div class="paragraph">
<p>Logs can be snapshot automatically by setting <code>RAFT.max_log_size</code> to the max number of bytes that a log is allowed to
grow to until a snapshot is taken.</p>
</div>
</div>
<div class="sect3">
<h4 id="_miscellaneous_methods">2.2.5. Miscellaneous methods</h4>
<div class="paragraph">
<p>Other methods in <code>RaftHandle</code> include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">leader()</dt>
<dd>
<p>Returns the address of the current Raft leader, or null if there is no leader (e.g. in case there was no
majority to elect a leader)</p>
</dd>
<dt class="hdlist1">isLeader()</dt>
<dd>
<p>Whether or not the current member is the leader</p>
</dd>
<dt class="hdlist1">addRoleListener(RAFT.RoleChange listener)</dt>
<dd>
<p>Allows to register a  <code>RoleChange</code> listener which is notified when the current
member changes its role (<code>Leader</code>, <code>Follower</code>, <code>Candidate</code>)</p>
</dd>
<dt class="hdlist1">currentTerm()</dt>
<dd>
<p>Returns the current term (see Raft for details)</p>
</dd>
<dt class="hdlist1">lastApplied()</dt>
<dd>
<p>Returns the index of the last log entry that was appended to the log</p>
</dd>
<dt class="hdlist1">commitIndex()</dt>
<dd>
<p>Returns the index of the last log entry that was committed</p>
</dd>
<dt class="hdlist1">raft()</dt>
<dd>
<p>Returns a reference to the <code>RAFT</code> protocol in the current member&#8217;s stack. Provided for experts who need to
access <code>RAFT</code> directly.</p>
</dd>
<dt class="hdlist1">raftId(String id)</dt>
<dd>
<p>Used to set the <code>raft_id</code> programmatically (note that this can also be done by setting <code>raft_id</code> in
<code>RAFT</code> in the XML configuration. For example, the following code sets <code>raft_id</code> from the command line:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected void start(String raft_id) throws Exception {
    JChannel ch=new JChannel("raft.xml").name(raft_id);   <img src="./images/icons/callouts/2.png" alt="2">
    RaftHandle handle=new RaftHandle(ch, this).raftId(raft_id); <img src="./images/icons/callouts/3.png" alt="3">
    ch.connect("raft-cluster");  <img src="./images/icons/callouts/4.png" alt="4">
}

public static void main(String[] args) throws Exception {
    new bla().start(args[0]);  <img src="./images/icons/callouts/1.png" alt="1">
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>The <code>raft_id</code> can for example be passed to the program as an argument</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>The channel is created and its logical name set to be the same as <code>raft_id</code>. This is not necessary, but convenient.</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>Now <code>raft_id</code> can be set via <code>RaftHandle.raftId(String id)</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuration">2.3. Configuration</h3>
<div class="paragraph">
<p>The configuration of a member is either done declaratively via an XML config file or programmatically. Refer to the
JGroups documentation for details.</p>
</div>
<div class="paragraph">
<p>A sample XML configuration file is shown below (edited for brevity):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;config xmlns="urn:org:jgroups"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd"&gt;
    &lt;UDP
         mcast_addr="228.5.5.5"
         mcast_port="${jgroups.udp.mcast_port:45588}"/&gt;
    &lt;PING /&gt;
    &lt;MERGE3 /&gt;
    &lt;FD_SOCK/&gt;
    &lt;FD_ALL/&gt;
    &lt;VERIFY_SUSPECT timeout="1500"  /&gt;
    &lt;pbcast.NAKACK2 xmit_interval="500"/&gt;
    &lt;UNICAST3 xmit_interval="500"/&gt;
    &lt;pbcast.STABLE desired_avg_gossip="50000"
                   max_bytes="4M"/&gt;
    &lt;raft.NO_DUPES/&gt;                                                         <img src="./images/icons/callouts/1.png" alt="1">
    &lt;pbcast.GMS print_local_addr="true" join_timeout="2000"/&gt;
    &lt;UFC max_credits="2M" min_threshold="0.4"/&gt;
    &lt;MFC max_credits="2M" min_threshold="0.4"/&gt;
    &lt;FRAG2 frag_size="60K"  /&gt;
    &lt;raft.ELECTION election_min_interval="100" election_max_interval="500"/&gt; <img src="./images/icons/callouts/2.png" alt="2">
    &lt;raft.RAFT members="A,B,C,D" raft_id="${raft_id:undefined}"/&gt;            <img src="./images/icons/callouts/3.png" alt="3">
    &lt;raft.REDIRECT/&gt;                                                         <img src="./images/icons/callouts/4.png" alt="4">
    &lt;raft.CLIENT bind_addr="0.0.0.0" /&gt;                                      <img src="./images/icons/callouts/5.png" alt="5">
&lt;/config&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td><code>NO_DUPES</code>: checks that joining a new member doesn&#8217;t lead to duplicate <code>raft_ids</code> in the membership. Rejects the
JOIN if it would. Must be placed somewhere <em>below</em> <code>GMS</code></td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td><code>ELECTION</code>: this protocol implements leader election, as defined in Raft. It is independent from <code>RAFT</code> and could
(and may, in the future) be replaced with a different election protocol. Attributes <code>election_min_interval</code> and
<code>election_max_interval</code> define the range from which jgroups-raft picks a random election timeout.</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td><code>RAFT</code>: the main protocol implementing log appending and committing, handling state machine updates, snapshotting etc.
Attribute <code>members</code> defines the (fixed) membership (may still be redfined by <code>addServer</code>/<code>removeServer</code> log entries
when initializing a member from the persistent log). Attribute <code>raft_id</code> defines the ID of the current member (needs
to be an element of <code>members</code>, as discussed earlier).</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/4.png" alt="4"></td>
<td><code>REDIRECT</code> is used to redirect requests to the current Raft leader, or to throw an exception if no member is leader</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/5.png" alt="5"></td>
<td><code>CLIENT</code> listens on a socket (port <code>1965</code> by default) for client requests, executes them and sends the result back
to the clients. Currently, <code>addServer</code> and <code>removeServer</code> has been implemented.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is a regular JGroups XML configuration, except that jgroups-raft added a few additional protocols.</p>
</div>
</div>
<div class="sect2">
<h3 id="DynamicMembership">2.4. Adding and removing members dynamically</h3>
<div class="paragraph">
<p>The <code>RAFT</code> protocol provides methods <code>addServer(String raft_id)</code> and <code>removeServer(String raft_id)</code> to add and remove
servers from the static membership (defined by <code>RAFT.members</code>). Only one server at a time can be added and removed, and
adding or removing a server needs a majority ack to be committed.</p>
</div>
<div class="paragraph">
<p>Both methods are exposed via JMX, so <code>jconsole</code> could be used. However, jgroups-raft also provides a script
(<code>client.sh</code>) to do this in a more convenient way. The script uses <code>Client</code> to connect to a member&#8217;s <code>CLIENT</code> protocol
running at <code>localhost:1965</code> (can be changed). The request is then forwarded to the current leader.</p>
</div>
<div class="paragraph">
<p>The steps to add a member are as follows (say we have <code>RAFT.members="A,B,C"</code> and want to add "D"):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Call <code>bin/client.sh -add D</code></p>
<div class="ulist">
<ul>
<li>
<p>If needed, <code>-port PORT</code> or <code>-bind_addr ADDR</code> can be given, e.g. if we need to reach a member running on a different host</p>
</li>
</ul>
</div>
</li>
<li>
<p>Once <code>A</code> (the leader) processed <code>addServer("D")</code>, everybody&#8217;s <code>RAFT.members</code> is <code>"A","B","C","D"</code></p>
</li>
<li>
<p>At this point, the XML configuration files should be updated so that <code>RAFT.members="A,B,C,D"</code></p>
</li>
<li>
<p>If not, members will read the correct membership when getting initialized by their logs</p>
</li>
<li>
<p>A new member <code>D</code> can now be started (its XML config needs to have the correct <code>members</code> attribute !)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="BuildingBlocks">3. Building blocks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Similar to JGroups' building blocks, jgroups-raft also has building blocks, which provide additional functionality on
top of a <code>RaftHandle</code>. They are typically given a JChannel, create a <code>RaftHandle</code> and register themselves as
<code>StateMachine</code> with the handle. Building blocks offer a different interface to the users, e.g. a replicated hashmap
with puts and gets, or a distributed counter or lock.</p>
</div>
<div class="sect2">
<h3 id="ReplicatedStateMachine">3.1. ReplicatedStateMachine</h3>
<div class="paragraph">
<p><code>ReplicatedStateMachine</code> is a key-value store replicating its contents to all cluster members. Contrary to the JGroups
equivalent (<code>ReplicatedHashMap</code>), changes are replicated by consensus and logged to a persistent log.</p>
</div>
<div class="paragraph">
<p>While the JGroups version is allowed to make progress during network partitions, and users need to merge possibly
diverging state from different partitions after a partition heals, <code>ReplicatedStateMachine</code> will allow progress only in
the <em>majority partition</em>, so no state merging needs to be done after a partition heals.</p>
</div>
<div class="paragraph">
<p>Not having to merge state is certainly simpler, but comes at the expense of availability: if <code>N/2+1</code> members leave or
split into different partitions, <code>ReplicatedStateMachine</code> will be unavailable (all requests will time out).</p>
</div>
<div class="paragraph">
<p>However, the advantage is that the members' states will never diverge.</p>
</div>
<div class="paragraph">
<p><code>ReplicatedStateMachine</code> requires a <code>JChannel</code> in its constructor and has <code>put()</code>, <code>get()</code> and <code>remove()</code> methods.
The code below shows how to create an instance of <code>ReplicatedStateMachine</code> and add an element to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected void start(String raft_id) throws Exception {
    JChannel ch=new JChannel("raft.xml").name(raft_id);
    ReplicatedStateMachine&lt;String,String&gt; rsm=new ReplicatedStateMachine&lt;&gt;(ch)
        .raftId(raft_id);
    ch.connect("rsm-cluster");
    rsm.put("name", "Bela");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s a demo <code>ReplicatedStateMachineDemo</code> which can be used to interactively use <code>ReplicatedStateMachine</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="CounterService">3.2. CounterService</h3>
<div class="paragraph">
<p><code>CounterService</code> provides a replicated counter which can get be set, get and compare-and-set, implementing JGroups'
<code>Counter</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public interface Counter {
    public long    get();
    public void    set(long new_value);
    public boolean compareAndSet(long expect, long update);
    public long    incrementAndGet();
    public long    decrementAndGet();
    public long    addAndGet(long delta);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>Counter</code> implementation is created via the <code>CounterService</code> building block (edited):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CounterService implements StateMachine {
    public CounterService(Channel ch);
    public long           replTimeout();
    public CounterService replTimeout(long timeout);
    public boolean        allowDirtyReads();
    public CounterService allowDirtyReads(boolean flag);
    public CounterService raftId(String id);

    /**
     * Returns an existing counter, or creates a new one if none exists
     * @param name Name of the counter, different counters have to have different names
     * @param initial_value The initial value of a new counter if there is no existing counter.
     * Ignored if the counter already exists
     * @return The counter implementation
     */
    public Counter getOrCreateCounter(String name, long initial_value) throws Exception;


    /**
     * Deletes a counter instance (on the coordinator)
     * @param name The name of the counter. No-op if the counter doesn't exist
     */
    public void deleteCounter(String name) throws Exception;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>CounterService</code> is mainly used to get an existing or create a new <code>Counter</code> implementation (<code>getOrCreateCounter()</code>), or
to delete an existing counter (<code>deleteCounter()</code>).</p>
</div>
<div class="paragraph">
<p>To create an instance of <code>CounterService</code>, a JChannel has to be passed to the constructor. The sample code below
shows how to use this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">protected void start(String raft_id) throws Exception {
    JChannel ch=new JChannel("raft.xml").name(raft_id);
    CounterService cs=new CounterService(ch);               <img src="./images/icons/callouts/1.png" alt="1">
    ch.connect("counter-cluster");
    Counter counter=cs.getOrCreateCounter("mycounter", 1);  <img src="./images/icons/callouts/2.png" alt="2">
    counter.incrementAndGet();                              <img src="./images/icons/callouts/3.png" alt="3">
    counter.compareAndSet(2, 5);                            <img src="./images/icons/callouts/4.png" alt="4">
    long current_value=counter.get();                       <img src="./images/icons/callouts/5.png" alt="5">
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>First a <code>CounterService</code> is created and given a reference to a channel</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>Once the member has joined the cluster, we create a counter named "mycounter" with an initial value of 1</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>The counter is then incremented to 2</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/4.png" alt="4"></td>
<td>Now a compare-and-set operation sets the counter to 5 if it was 2</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/5.png" alt="5"></td>
<td>The last operation fetches the current value of "mycounter"</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Any member in the cluster can change the same counter and all operations are ordered by the Raft leader, which causes
the replicated counters to have exactly the same value in all members.</p>
</div>
<div class="paragraph">
<p>Comparing this to the JGroups equivalent, a jgroups-raft counter never diverges in different members, again at the
expense of availability. In the JGroups version, counters are always available, but may diverge, e.g. in a split brain
scenario, and have to be reconciled by the application after the split brain is resolved.</p>
</div>
<div class="paragraph">
<p>There&#8217;s a demo <code>CounterServiceDemo</code> which can be used to interactively manipulate replicated counters.</p>
</div>
<div class="sect3">
<h4 id="_reads_and_consensus">3.2.1. Reads and consensus</h4>
<div class="paragraph">
<p>Currently (as of jgroups-raft version 0.4), reading a counter is by default <em>dirty</em>, meaning that a read may return a
stale value.</p>
</div>
<div class="paragraph">
<p>This can be changed by calling <code>counter_service.allowDirtyReads(false)</code>.</p>
</div>
<div class="paragraph">
<p>However, this inserts a dummy <em>read log entry</em> which returns the value of counter when committed. Since this dummy entry
is ordered correctly wrt writes in the log, it will always return correct values.</p>
</div>
<div class="paragraph">
<p>The cost is that reads take up space in the persistent logs and that we need consensus (majority) for reads. In the next
release of jgroups-raft, the mechanism for client reads as suggested in the Raft paper will be implemented. See
<a href="https://github.com/belaban/jgroups-raft/issues/18">Issue 18</a> for details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
Non-dirty reads has not yet been implemented in <code>ReplicatedStateMachine</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cluster_singleton_service">3.3. Cluster singleton service</h3>
<div class="paragraph">
<p>A <em>singleton service</em> is a service which is supposed to run only once in an entire cluster. Typically, in JGroups, a
singleton service is started on the first member of a cluster. For example, if we have <code>{A,B,C,D,E}</code>, the singleton
service (or services) would be running on <code>A</code>.</p>
</div>
<div class="paragraph">
<p>If we have a partition, such that the cluster falls apart into <code>{A,B,C}</code> and <code>{D,E}</code>, then an <em>additional</em> singleton
would be started on <code>D</code>, as <code>D</code> became coordinator and doesn&#8217;t know <code>{A,B,C}</code> didn&#8217;t leave, but were partitioned away
instead.</p>
</div>
<div class="paragraph">
<p>When the partition ends, if <code>D</code> is not coordinator anymore, it would stop its singleton services.</p>
</div>
<div class="paragraph">
<p>If multiple singletons (as provided by JGroups, e.g. during a network split) cannot be tolerated by the application,
and the application has a requirement that <em>at most one singleton service</em> can be running (better none than two),
jgroups-raft can be used.</p>
</div>
<div class="paragraph">
<p>The mechanism to implement singleton services in jgroups-raft is leader election: it is guaranteed that at most one
leader exists in a given cluster at the same time. This is exactly what we need for singletons. The code below shows
how to do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">JChannel ch=null;
RaftHandle handle=new RaftHandle(ch, this); <img src="./images/icons/callouts/1.png" alt="1">
handle.addRoleListener(role -&gt; {            <img src="./images/icons/callouts/2.png" alt="2">
    if(role == Role.Leader)                 <img src="./images/icons/callouts/3.png" alt="3">
        // start singleton services
    else
        // stop singleton services
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>A <code>RaftHandle</code> is created over a channel</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>A <code>RAFT.RoleChange</code> callback is registered with the handle. Alternatively, <code>addRoleListener()</code> could be called
directly on an instance of <code>RAFT</code> retrieved from the protocol stack associated with the given channel</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>When we become the Raft leader, the singleton services can be started, when not, they should be stopped (if running)</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="protlist">4. List of protocols</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes the most frequently used protocols, and their configuration.</p>
</div>
<div class="paragraph">
<p>Meanwhile, we recommend that users should copy one of the predefined configurations (shipped with jgroups-raft), e.g.
<code>raft.xml</code>, and make only minimal changes to it.</p>
</div>
<div class="sect2">
<h3 id="NO_DUPES">4.1. NO_DUPES</h3>
<div class="paragraph">
<p>This protocol prevents duplicate members from joining the cluster. The protocol needs to be located somewhere below
<code>GMS</code>.</p>
</div>
<div class="paragraph">
<p><code>NO_DUPES</code> catches JOIN requests from a joiner to the JGroups coordinator and checks if the joiner&#8217;s <code>raft_id</code> is
already contained in the current membership, and rejects the JOIN if this is the case.</p>
</div>
<div class="paragraph">
<p>For example, if we have current members <code>{A,B}</code> and another member with <code>raft_id</code> "B" joins, then the joiner would
get the following exception when trying to join the cluster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>-------------------------------------------------------------------
GMS: address=B, cluster=cntrs, physical address=127.0.0.1:64733
-------------------------------------------------------------------
Exception in thread "main" java.lang.Exception: connecting to channel "cntrs" failed
	at org.jgroups.JChannel._connect(JChannel.java:570)
	at org.jgroups.JChannel.connect(JChannel.java:294)
	at org.jgroups.JChannel.connect(JChannel.java:279)
	at org.jgroups.raft.demos.CounterServiceDemo.start(CounterServiceDemo.java:32)
	at org.jgroups.raft.demos.CounterServiceDemo.main(CounterServiceDemo.java:163)
Caused by: java.lang.SecurityException: join of B rejected as it would create a view with duplicate members (current view: [B|1] (2) [B, A])
	at org.jgroups.protocols.pbcast.ClientGmsImpl.isJoinResponseValid(ClientGmsImpl.java:187)
	at org.jgroups.protocols.pbcast.ClientGmsImpl.installViewIfValidJoinRsp(ClientGmsImpl.java:153)
	at org.jgroups.protocols.pbcast.ClientGmsImpl.joinInternal(ClientGmsImpl.java:111)
	at org.jgroups.protocols.pbcast.ClientGmsImpl.join(ClientGmsImpl.java:41)
	at org.jgroups.protocols.pbcast.GMS.down(GMS.java:1087)
	at org.jgroups.protocols.FlowControl.down(FlowControl.java:353)
	at org.jgroups.protocols.FlowControl.down(FlowControl.java:353)
	at org.jgroups.protocols.FRAG2.down(FRAG2.java:136)
	at org.jgroups.protocols.RSVP.down(RSVP.java:153)
	at org.jgroups.protocols.pbcast.STATE_TRANSFER.down(STATE_TRANSFER.java:202)
	at org.jgroups.protocols.raft.ELECTION.down(ELECTION.java:112)
	at org.jgroups.protocols.raft.RAFT.down(RAFT.java:442)
	at org.jgroups.protocols.raft.REDIRECT.down(REDIRECT.java:103)
	at org.jgroups.stack.ProtocolStack.down(ProtocolStack.java:1038)
	at org.jgroups.JChannel.down(JChannel.java:791)
	at org.jgroups.JChannel._connect(JChannel.java:564)
	... 4 more
[mac] /Users/bela/jgroups-raft$</pre>
</div>
</div>
<div class="paragraph">
<p>The error message is <code>SecurityException: join of B rejected as it would create a view with duplicate members (current view: [B|1] (2) [B, A])</code>,
which shows that view <code>{B,A}</code> already contains a member with <code>raft_id</code> <code>B</code>, and so the JOIN request of the new member
is rejected.</p>
</div>
</div>
<div class="sect2">
<h3 id="ELECTION">4.2. ELECTION</h3>
<div class="paragraph">
<p><code>ELECTION</code> is the protocol which performs leader election, as defined by Raft.
Its attributes define the election timeout and the heartbeat interval (see Raft for details).</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 90%;">
<caption class="title">Table 1. ELECTION</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">election_max_interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Max election interval (ms). The actual election interval is computed as a random value in range [election_min_interval..election_max_interval]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">election_min_interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Min election interval (ms)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">heartbeat_interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interval (in ms) at which a leader sends out heartbeats</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="RAFT">4.3. RAFT</h3>
<div class="paragraph">
<p><code>RAFT</code> is the main protocol in jgroups-raft; it implements log appending and committing, snapshotting and log compaction,
syncing of new members and so on.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 90%;">
<caption class="title">Table 2. RAFT</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">log_args</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arguments to the log impl, e.g. k1=v1,k2=v2. These will be passed to init()</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">log_class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The fully qualified name of the class implementing Log</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">log_name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the log. The logical name of the channel (if defined) is used by default. Note that logs for different processes on the same host need to be different</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">max_log_size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Max number of bytes a log can have until a snapshot is created</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">members</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of members (logical names); majority is computed from it</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">raft_id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The identifier of this node. Needs to be unique and an element of members. Must not be null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">resend_interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interval (ms) at which AppendEntries messages are resent to members which haven&#8217;t received them yet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">snapshot_name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the snapshot. By default, &lt;log_name&gt;.snapshot will be used</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="REDIRECT">4.4. REDIRECT</h3>
<div class="paragraph">
<p>The <code>REDIRECT</code> protocol needs to be somewhere above <code>RAFT</code>. It keeps track of the current Raft leader and redirects
requests to the right leader. If there is no leader, e.g. because there&#8217;s no majority to elect one, an exception will
be thrown.</p>
</div>
</div>
<div class="sect2">
<h3 id="CLIENT">4.5. CLIENT</h3>
<div class="paragraph">
<p><code>CLIENT</code> listens on a socket for client requests. When a request is received, it is sent down where it will be forwarded
(by <code>REDIRECT</code>) to the current leader which executes the request. The responses is then sent back to the client.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 90%;">
<caption class="title">Table 3. CLIENT</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bind_addr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The bind address which should be used by the server socket. The following special values are also recognized: GLOBAL, SITE_LOCAL, LINK_LOCAL, NON_LOOPBACK, match-interface, match-host, match-address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">idle_time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of ms a thread can be idle before being removed from the thread pool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">max_threads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Max number of threads in the thread pool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">min_threads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The min threads in the thread pool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Port to listen for client requests</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-08-04 11:44:42 CEST
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>